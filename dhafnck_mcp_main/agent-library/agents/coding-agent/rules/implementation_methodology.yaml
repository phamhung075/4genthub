implementation_methodology:
  objective: |
    To write production-ready code based on the detailed plan.
    Maintain context utilization under 40% for optimal LLM performance.
    Execute implementation through parallel sub-agents with focused context.
    
  importance: |
    A well-defined plan is crucial for the agent to generate code effectively.
    Maintaining context utilization below 40% is a key principle for optimizing LLM performance.
    The quality of output is directly tied to the quality of the context input.
    Parallel execution with minimal context prevents information overload and improves accuracy.
    
  context_management:
    max_utilization: 40%
    strategies:
      - selective_context: Only include directly relevant files and snippets
      - context_windowing: Use new context window for each implementation phase
      - context_delegation: Pass only necessary context to sub-agents
      - context_pruning: Remove completed work from active context
      
    context-per-agent:
      description: Each sub-agent receives only what they need
      includes:
        - target_files: Only files being modified
        - relevant_snippets: Specific code sections needed
        - dependencies: Direct dependencies only
        - requirements: Specific requirements for their task
      excludes:
        - unrelated_files: Files not being modified
        - historical_context: Previous implementation details
        - other_agent_work: Work assigned to other agents
        - verbose_documentation: Full docs, only summaries
        
  parallel_execution:
    strategy: |
      Divide implementation into independent units that can be executed in parallel.
      Each sub-agent works on their assigned piece with minimal shared context.
      
    delegation_pattern:
      - identify_independent_units: Find code that can be written independently
      - assign_to_sub_agents: Delegate each unit to specialized agent
      - provide_minimal_context: Give only necessary information
      - coordinate_results: Merge completed work from all agents
      
    sub_agent_allocation:
      example:
        - backend_api: "coding-agent with API context only"
        - frontend_ui: "@ui-specialist-agent with UI context only"
        - database_layer: "coding-agent with DB schema only"
        - tests: "@test-orchestrator-agent with interfaces only"
        - deployment: "devops-agent with config context only"
        
  implementation_process:
    phases:
      - preparation:
          description: Review plan and prepare context
          actions:
            - load_plan: Load detailed implementation plan
            - identify_files: List files to create/modify
            - calculate_context: Ensure under 40% utilization
            - prepare_sub_contexts: Create focused contexts for sub-agents
            
      - execution:
          description: Write code based on plan
          actions:
            - delegate_work: Assign tasks to parallel sub-agents
            - monitor_progress: Track completion status
            - manage_context: Keep utilization under 40%
            - coordinate_outputs: Collect results from sub-agents
            
      - integration:
          description: Merge parallel work
          actions:
            - collect_outputs: Gather code from all sub-agents
            - resolve_conflicts: Handle any integration issues
            - validate_integration: Ensure components work together
            - cleanup_context: Remove completed work from memory
            
      - verification:
          description: Verify implementation matches plan
          actions:
            - compare_to_plan: Check all requirements met
            - run_basic_checks: Syntax and compilation checks
            - document_deviations: Note any changes from plan
            - prepare_handoff: Package for testing phase
            
  quality_standards:
    code_quality:
      - follows_conventions: Matches existing code style
      - properly_typed: Includes type annotations
      - well_structured: Clear organization and flow
      - performant: Efficient algorithms and patterns
      
    context_efficiency:
      - utilization_check: Always verify < 40%
      - relevance_score: Only highly relevant context
      - pruning_frequency: Remove unused context regularly
      - measurement: Track tokens used vs available
      
    parallel_coordination:
      - independence: Sub-agents work without conflicts
      - communication: Minimal inter-agent dependencies
      - synchronization: Clear merge points defined
      - error_isolation: Issues don't cascade between agents
      
  output_specification:
    primary_output:
      - production_code: Ready-to-deploy implementation
      - file_changes: All created/modified files
      - integration_points: How components connect
      - verification_results: Basic check outcomes
      
    metadata:
      - context_utilization: Percentage used during implementation
      - parallel_agents_used: Which agents worked on what
      - implementation_time: Duration of implementation
      - deviations_from_plan: Any changes made
      
  example_implementation:
    scenario: "Implement authentication system"
    
    context_allocation:
      total_available: "100,000 tokens"
      target_usage: "40,000 tokens (40%)"
      distribution:
        - plan_reference: "5,000 tokens"
        - code_templates: "10,000 tokens"
        - dependencies: "8,000 tokens"
        - active_work: "15,000 tokens"
        - buffer: "2,000 tokens"
        
    parallel_delegation:
      - agent: "coding-agent"
        task: "JWT service implementation"
        context_provided:
          - "jwt.service.ts plan section"
          - "JWT library docs summary"
          - "Interface definitions"
        context_size: "8,000 tokens"
        
      - agent: "coding-agent" 
        task: "Auth middleware"
        context_provided:
          - "middleware.ts plan section"
          - "Express middleware pattern"
          - "JWT service interface"
        context_size: "7,000 tokens"
        
      - agent: "@test-orchestrator-agent"
        task: "Auth tests"
        context_provided:
          - "Test plan section"
          - "API interfaces"
          - "Test framework setup"
        context_size: "6,000 tokens"
        
      - agent: "devops-agent"
        task: "Deployment config"
        context_provided:
          - "Deployment plan"
          - "Environment variables"
          - "Docker template"
        context_size: "5,000 tokens"
        
    coordination:
      - execution: "All 4 agents work simultaneously"
      - duration: "Reduced from sequential 4 hours to parallel 1 hour"
      - integration: "Merge results after all complete"
      - context_total: "26,000 tokens (26% utilization)"
      
  best_practices:
    - plan_first: Never implement without detailed plan
    - measure_context: Check utilization before starting
    - delegate_wisely: Use parallel agents for independent work
    - focus_context: Each agent gets only what they need
    - monitor_usage: Track context throughout implementation
    - clean_regularly: Remove completed work from context
    - verify_output: Ensure matches plan requirements