# JWT Secret Configuration Debug Analysis

## Executive Summary

The JWT secret mismatch is caused by **two separate authentication systems using different JWT secrets** in the same application. This creates a validation conflict where tokens generated by one system cannot be validated by the other.

## Root Cause Analysis

### 1. Two Different JWT Secrets

From `.env` file analysis:
- **JWT_SECRET_KEY**: `dGhpcyBpcyBhIGR1bW15IGp3dCBzZWNyZXQgZm9yIGRldmVsb3BtZW50` (56 chars)
- **SUPABASE_JWT_SECRET**: `xQVwQQIPe9X00jzJT64CkDnt2/IDmst4TjzNDIVfg0T8ADxlsUZDK+SOtaBs6lYuEttroRNHIOGMPYmoyHHs7A==` (88 chars)

### 2. Middleware Layer Configuration

#### JWTAuthMiddleware (`jwt_auth_middleware.py`)
- **Location**: Lines 21-23
- **Secret Source**: Constructor parameter `secret_key` 
- **Configuration**: Takes secret from the caller (typically `JWT_SECRET_KEY`)
- **Usage**: Validates tokens in `extract_user_from_token()` method (line 51-55)

#### DualAuthMiddleware (`dual_auth_middleware.py`)
- **Location**: Lines 286-287
- **Secret Source**: `os.getenv("JWT_SECRET_KEY", "default-secret-key-change-in-production")`
- **Usage**: Local JWT validation in MCP requests (line 291-294)
- **Fallback**: Falls back to `default-secret-key-change-in-production` if env var not set

#### JWTAuthBackend (`jwt_auth_backend.py`)
- **Location**: Lines 59-61 (initialization), Lines 136-139 (Supabase validation)
- **Secret Sources**: 
  - **Local JWT**: `os.getenv("JWT_SECRET_KEY")` (required, raises error if missing)
  - **Supabase JWT**: `os.getenv("SUPABASE_JWT_SECRET")` (optional, skips if missing)
- **Validation Strategy**: Dual validation approach (lines 108-189)
  1. Try local JWT secret first for types "access" and "api_token"
  2. Try Supabase JWT secret as fallback

### 3. Validation Flow Through Middleware

#### Middleware Execution Order (from `mcp_entry_point.py` line 690):
1. **DualAuthMiddleware** (added first)
   - Detects request type (frontend vs MCP)
   - For MCP requests: Uses local JWT validation with `JWT_SECRET_KEY`
   - For frontend requests: Uses Supabase authentication

2. **JWTAuthBackend** (used by MCP auth system)
   - Implements dual validation strategy
   - Tries both `JWT_SECRET_KEY` and `SUPABASE_JWT_SECRET`

### 4. Token Generation vs Validation Mismatch

#### Token Generation (Frontend):
- **Location**: Likely uses Supabase client
- **Secret**: Uses `SUPABASE_JWT_SECRET` (88 chars)
- **Algorithm**: HS256
- **Claims**: Supabase-specific format

#### Token Validation (Backend):
- **Primary Path**: `DualAuthMiddleware` â†’ Local JWT validation
- **Secret**: Uses `JWT_SECRET_KEY` (56 chars)
- **Expected Format**: Local token format

## Specific Code Locations

### Environment Variable Usage:

1. **JWT_SECRET_KEY** (56 chars) used in:
   - `jwt_auth_middleware.py` - Constructor parameter
   - `dual_auth_middleware.py:286` - Direct env access
   - `jwt_auth_backend.py:59` - Direct env access (required)
   - Multiple other files (18+ references found)

2. **SUPABASE_JWT_SECRET** (88 chars) used in:
   - `jwt_auth_backend.py:136` - Supabase token validation
   - `.env:207` - Configuration value

### Critical Validation Points:

1. **DualAuthMiddleware MCP Authentication** (`dual_auth_middleware.py:286`):
```python
jwt_secret = os.getenv("JWT_SECRET_KEY", "default-secret-key-change-in-production")
jwt_service = JWTService(secret_key=jwt_secret)
payload = jwt_service.verify_token(token, expected_type="api_token")
```

2. **JWTAuthBackend Dual Validation** (`jwt_auth_backend.py:108-189`):
```python
# Try local JWT service first
payload = self._jwt_service.verify_token(token, expected_type=token_type)

# Try Supabase JWT secret as fallback
payload = pyjwt.decode(token, supabase_jwt_secret, algorithms=["HS256"])
```

## Recommended Solutions

### Option 1: Unify JWT Secrets (Recommended)

**Change the application to use a single JWT secret:**

1. **Update `.env`** - Use the same secret for both variables:
```bash
JWT_SECRET_KEY=xQVwQQIPe9X00jzJT64CkDnt2/IDmst4TjzNDIVfg0T8ADxlsUZDK+SOtaBs6lYuEttroRNHIOGMPYmoyHHs7A==
SUPABASE_JWT_SECRET=xQVwQQIPe9X00jzJT64CkDnt2/IDmst4TjzNDIVfg0T8ADxlsUZDK+SOtaBs6lYuEttroRNHIOGMPYmoyHHs7A==
```

2. **Update token generation** to use the unified secret

### Option 2: Fix Validation Order

**Ensure JWTAuthBackend dual validation is used everywhere:**

1. **Modify DualAuthMiddleware** (`dual_auth_middleware.py:279-307`) to use the same dual validation logic as JWTAuthBackend
2. **Replace direct JWT validation** with calls to JWTAuthBackend methods

### Option 3: Environment Variable Consolidation

**Use a single JWT_SECRET environment variable:**

1. **Update all references** to use `JWT_SECRET` instead of separate variables
2. **Update configuration files** and documentation

## Testing Validation

After implementing the fix, test with:

1. **Frontend-generated tokens** (Supabase format)
2. **Backend-generated tokens** (Local format)  
3. **MCP client tokens** (API token format)

Ensure all three token types validate successfully through all middleware layers.

## Files Requiring Changes

Based on the analysis, the following files need modification:

1. **`.env`** - Unify JWT secrets
2. **`dual_auth_middleware.py`** - Use dual validation approach
3. **Token generation endpoints** - Ensure consistent secret usage
4. **Configuration files** - Update documentation

## Security Considerations

- The current 56-character `JWT_SECRET_KEY` is adequate but the 88-character `SUPABASE_JWT_SECRET` provides better entropy
- Using the longer secret for both systems improves security
- Ensure all environments (dev/staging/prod) use the same approach