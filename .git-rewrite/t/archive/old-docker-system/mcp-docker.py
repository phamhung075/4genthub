#!/usr/bin/env python3
import subprocess
import questionary
import datetime
import os
import signal
import sys
import sqlite3
import json
import shutil
from typing import Optional
from pathlib import Path

# Try to import PostgreSQL support
try:
    import psycopg2
    HAS_POSTGRESQL = True
except ImportError:
    HAS_POSTGRESQL = False

# Load environment variables from .env files
def load_env_file(env_file_path: str) -> dict:
    """Load environment variables from a .env file"""
    env_vars = {}
    if os.path.exists(env_file_path):
        with open(env_file_path, 'r') as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith('#') and '=' in line:
                    key, value = line.split('=', 1)
                    env_vars[key.strip()] = value.strip()
    return env_vars

def load_all_env_vars() -> dict:
    """Load environment variables from multiple .env files"""
    env_vars = os.environ.copy()
    
    # Define possible .env file locations (in order of priority)
    possible_env_files = [
        # Local .env file (highest priority)
        '.env',
        # Root project .env file
        '../.env',
        # Main project .env file
        '../dhafnck_mcp_main/.env',
        # Absolute path to root .env
        '/home/daihungpham/agentic-project/.env',
        # Absolute path to main .env
        '/home/daihungpham/agentic-project/dhafnck_mcp_main/.env'
    ]
    
    # Load from each file (later files override earlier ones)
    for env_file in possible_env_files:
        if os.path.exists(env_file):
            file_env_vars = load_env_file(env_file)
            env_vars.update(file_env_vars)
            print(f"üìã Loaded environment variables from: {env_file}")
    
    # Debug: Show REDIS_PASSWORD loading status (if needed)
    # redis_pwd = env_vars.get('REDIS_PASSWORD', 'NOT_FOUND')
    # print(f"üîç REDIS_PASSWORD loaded: {redis_pwd}")
    
    return env_vars

# Load environment variables at startup
ENV_VARS = load_all_env_vars()

# Export critical environment variables to the current process
# This ensures Docker Compose can access them during config parsing
exported_vars = []
for key, value in ENV_VARS.items():
    if key in ['REDIS_PASSWORD', 'DATABASE_URL', 'DATABASE_TYPE']:
        os.environ[key] = value
        exported_vars.append(f"{key}={value}")

if exported_vars:
    print(f"üîß Exported to current process: {', '.join([v.split('=')[0] for v in exported_vars])}")

# Create .env file in docker directory for Docker Compose
# Docker Compose looks for .env files in the same directory as docker-compose.yml
def create_docker_env_file():
    docker_env_path = os.path.join(os.path.dirname(__file__), '.env')
    critical_vars = ['REDIS_PASSWORD', 'DATABASE_URL', 'DATABASE_TYPE', 'NODE_ENV', 'LOG_LEVEL']
    
    with open(docker_env_path, 'w') as f:
        f.write("# Docker Compose environment variables\n")
        f.write("# This file is automatically generated by mcp-docker.py\n")
        f.write("# It contains environment variables needed by Docker Compose for variable substitution\n\n")
        
        for key in critical_vars:
            value = ENV_VARS.get(key)
            if value:
                f.write(f"{key}={value}\n")
            elif key == 'REDIS_PASSWORD':
                f.write(f"{key}=dev_redis_password_123\n")  # Default fallback
            elif key == 'DATABASE_TYPE':
                f.write(f"{key}=sqlite\n")  # Default fallback
            elif key == 'NODE_ENV':
                f.write(f"{key}=development\n")  # Default fallback
            elif key == 'LOG_LEVEL':
                f.write(f"{key}=INFO\n")  # Default fallback
    
    print(f"üîß Created docker/.env file for Docker Compose")

create_docker_env_file()

# Helper function to run subprocess with environment variables
def run_subprocess(cmd, **kwargs):
    """Run subprocess with loaded environment variables"""
    # Ensure environment variables are passed, merging with any existing env
    if 'env' in kwargs:
        # Merge existing env with loaded env vars
        merged_env = ENV_VARS.copy()
        merged_env.update(kwargs['env'])
        kwargs['env'] = merged_env
    else:
        kwargs['env'] = ENV_VARS
    
    # Debug: Show if REDIS_PASSWORD is in environment for docker-compose commands (if needed)
    # if ('docker-compose' in ' '.join(cmd) or 'compose' in ' '.join(cmd)) and 'down' in cmd:
    #     redis_pwd_value = kwargs['env'].get('REDIS_PASSWORD', 'NOT_SET')
    #     print(f"üîç Docker Compose DOWN Command - REDIS_PASSWORD: {redis_pwd_value}")
    
    return subprocess.run(cmd, **kwargs)

# Docker command detection
def get_docker_command():
    """Detect the appropriate Docker command to use."""
    # First, try native docker
    try:
        run_subprocess(["docker", "--version"], capture_output=True, check=True)
        return "docker"
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass
    
    # If native docker not found, try Windows Docker via WSL
    windows_docker = "/mnt/c/Program Files/Docker/Docker/resources/bin/docker.exe"
    if os.path.exists(windows_docker):
        try:
            run_subprocess([windows_docker, "--version"], capture_output=True, check=True)
            return windows_docker
        except subprocess.CalledProcessError:
            print("‚ö†Ô∏è  Docker Desktop found but not running. Please start Docker Desktop on Windows.")
            sys.exit(1)
    
    print("‚ùå Docker not found. Please either:")
    print("   1. Enable Docker Desktop WSL integration in Settings ‚Üí Resources ‚Üí WSL Integration")
    print("   2. Or start Docker Desktop on Windows")
    sys.exit(1)

def get_docker_compose_command():
    """Detect the appropriate docker-compose command to use."""
    docker_cmd = get_docker_command()
    
    # If using Windows Docker, use its compose
    if "docker.exe" in docker_cmd:
        compose_path = docker_cmd.replace("docker.exe", "docker-compose.exe")
        if os.path.exists(compose_path):
            return compose_path
    
    # Try docker compose (newer style)
    try:
        run_subprocess([docker_cmd, "compose", "version"], capture_output=True, check=True)
        return [docker_cmd, "compose"]
    except subprocess.CalledProcessError:
        pass
    
    # Try docker-compose (older style)
    try:
        run_subprocess(["docker-compose", "--version"], capture_output=True, check=True)
        return "docker-compose"
    except (subprocess.CalledProcessError, FileNotFoundError):
        pass
    
    print("‚ùå Docker Compose not found.")
    sys.exit(1)

# Helper function to flatten docker compose command
def flatten_compose_command(compose_cmd):
    """Convert docker compose command to a list."""
    if isinstance(compose_cmd, list):
        return compose_cmd
    else:
        return [compose_cmd]

# Get Docker commands once at startup
DOCKER = get_docker_command()
DOCKER_COMPOSE = get_docker_compose_command()

def get_compose_files(mode):
    """Get the appropriate compose files for each mode
    Returns a list of compose file arguments for Docker Compose.
    The order of files matters due to configuration overrides:
    - Base configuration is always included first (docker-compose.yml)
    - Mode-specific configurations are layered on top, overriding base settings if needed
    This ensures that mode-specific settings (like environment variables, volumes, or commands)
    take precedence over the base configuration.
    """
    base_files = ["-f", "dhafnck_mcp_main/docker/docker-compose.yml"]
    
    if mode == "normal":
        # Normal mode uses only the base configuration
        # No additional overrides; runs in production-like setup
        return base_files
    elif mode == "development":
        # Development mode builds on base configuration
        # Adds debug settings and possibly hot reload via volume mounts
        # Should run after base config is understood, as it overrides for dev environment
        return base_files + ["-f", "dhafnck_mcp_main/docker/docker-compose.dev.yml"]
    elif mode == "dev-fast":
        # Dev-fast mode is a variant of development, optimized for speed
        # Overrides base config with settings for quick iteration and debugging
        # Run after base config; assumes base services are defined
        return base_files + ["-f", "dhafnck_mcp_main/docker/docker-compose.dev-fast.yml"]
    elif mode == "local":
        # Local mode builds on base config but disables auth for ease of development
        # Intended for local testing without security overhead
        # Run after base config to ensure proper override of auth settings
        return base_files + ["-f", "dhafnck_mcp_main/docker/docker-compose.local.yml"]
    elif mode == "redis":
        # Redis mode extends base config with session persistence via Redis
        # Requires Redis service to be defined and started alongside main app
        # Run after base config; depends on main app setup before adding persistence layer
        return base_files + ["-f", "dhafnck_mcp_main/docker/docker-compose.redis.yml"]
    elif mode == "postgresql":
        # PostgreSQL mode uses PostgreSQL instead of SQLite
        # Provides production-ready database with JSONB support
        # Run for production-like setup with full database capabilities
        return ["-f", "dhafnck_mcp_main/docker/docker-compose.postgresql.yml"]
    else:
        # Fallback to base config if mode is unrecognized
        return base_files

def fix_database_permissions():
    """Fix database file permissions in the Docker container.
    
    This addresses the issue where database backups/restores change file ownership
    from the container user (dhafnck) to the host user (UID 1000), causing 
    'readonly database' errors when the container tries to write to the database.
    """
    print("üîß Fixing database permissions...")
    try:
        # Check if container is running
        result = run_subprocess(
            [DOCKER, "ps", "--filter", "name=dhafnck-mcp-server", "--format", "{{.Names}}"], 
            capture_output=True, text=True, check=True
        )
        
        if "dhafnck-mcp-server" in result.stdout:
            # Fix database file ownership and permissions
            run_subprocess([
                DOCKER, "exec", "--user", "root", "dhafnck-mcp-server", 
                "chown", "dhafnck:dhafnck", "/data/dhafnck_mcp.db"
            ], check=True)
            
            run_subprocess([
                DOCKER, "exec", "--user", "root", "dhafnck-mcp-server", 
                "chmod", "664", "/data/dhafnck_mcp.db"
            ], check=True)
            
            print("‚úÖ Database permissions fixed successfully!")
        else:
            print("‚ö†Ô∏è Container 'dhafnck-mcp-server' not found or not running.")
            
    except subprocess.CalledProcessError as e:
        print(f"‚ùå Error fixing database permissions: {e}")
    except Exception as e:
        print(f"‚ùå Unexpected error: {e}")

def rebuild_frontend_after_restore():
    """Rebuild frontend container after database restore to ensure UI shows new data.
    
    This ensures that the frontend displays the restored data correctly by:
    1. Stopping the current frontend container
    2. Rebuilding it with the latest code (no cache)
    3. Starting the updated container
    """
    print("  üì¶ Stopping current frontend container...")
    try:
        # Stop frontend container
        run_subprocess([
            "docker-compose", "-f", "dhafnck_mcp_main/docker/docker-compose.yml", 
            "down", "dhafnck-frontend"
        ], capture_output=True, text=True, check=True)
        
        print("  üî® Rebuilding frontend with latest code...")
        # Rebuild frontend container without cache
        run_subprocess([
            "docker-compose", "-f", "dhafnck_mcp_main/docker/docker-compose.yml", 
            "build", "dhafnck-frontend", "--no-cache"
        ], check=True)
        
        print("  üöÄ Starting updated frontend container...")
        # Start updated frontend
        run_subprocess([
            "docker-compose", "-f", "dhafnck_mcp_main/docker/docker-compose.yml", 
            "up", "-d", "dhafnck-frontend"
        ], check=True)
        
        print("‚úÖ Frontend rebuilt successfully!")
        print("üåê Frontend available at: http://localhost:3800")
        print("üí° Your restored data should now be visible in the UI")
        
    except subprocess.CalledProcessError as e:
        print(f"‚ö†Ô∏è Warning: Frontend rebuild failed: {e}")
        print("üí° You may need to manually rebuild the frontend container")
        print("   Run: docker-compose -f dhafnck_mcp_main/docker/docker-compose.yml build dhafnck-frontend --no-cache")
    except Exception as e:
        print(f"‚ùå Unexpected error during frontend rebuild: {e}")

def verify_postgresql_database() -> bool:
    """Verify PostgreSQL database connection and integrity"""
    print("üîç Verifying PostgreSQL database connection...")
    
    if not HAS_POSTGRESQL:
        print("‚ùå PostgreSQL support not available. Please install psycopg2: pip install psycopg2-binary")
        return False
    
    try:
        # Connect to PostgreSQL in container
        result = run_subprocess([
            "docker", "exec", "dhafnck-postgres", "psql", 
            "-U", "dhafnck_user", "-d", "dhafnck_mcp",
            "-c", "SELECT 1;"
        ], capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            print("‚úÖ PostgreSQL database connection successful")
            
            # Check for main tables
            result = run_subprocess([
                "docker", "exec", "dhafnck-postgres", "psql", 
                "-U", "dhafnck_user", "-d", "dhafnck_mcp",
                "-c", "SELECT table_name FROM information_schema.tables WHERE table_schema = 'public';"
            ], capture_output=True, text=True, timeout=10)
            
            if "global_contexts" in result.stdout and "project_contexts" in result.stdout:
                print("‚úÖ Database schema tables found")
                return True
            else:
                print("‚ö†Ô∏è Database schema tables not found. Database may need initialization.")
                return False
        else:
            print(f"‚ùå PostgreSQL connection failed: {result.stderr}")
            return False
            
    except subprocess.TimeoutExpired:
        print("‚ùå PostgreSQL connection timed out")
        return False
    except Exception as e:
        print(f"‚ùå Error verifying PostgreSQL database: {e}")
        return False

def verify_database_integrity(db_path: str) -> bool:
    """Verify database integrity and fix common issues"""
    print(f"üîç Verifying database integrity: {db_path}")
    
    try:
        conn = sqlite3.connect(db_path, timeout=10.0)
        cursor = conn.cursor()
        
        # Check integrity
        cursor.execute('PRAGMA integrity_check;')
        integrity = cursor.fetchone()[0]
        
        if integrity == 'ok':
            print("‚úÖ Database integrity check passed")
        else:
            print(f"‚ùå Database integrity check failed: {integrity}")
            conn.close()
            return False
        
        # Check and fix task counts
        print("üîß Checking and fixing task counts...")
        cursor.execute('SELECT git_branch_id, COUNT(*) FROM tasks GROUP BY git_branch_id')
        actual_counts = dict(cursor.fetchall())
        
        cursor.execute('SELECT git_branch_id, COUNT(*) FROM tasks WHERE status = "done" GROUP BY git_branch_id')
        completed_counts = dict(cursor.fetchall())
        
        cursor.execute('SELECT id, name FROM project_git_branchs')
        branches = cursor.fetchall()
        
        fixes = 0
        for branch_id, branch_name in branches:
            actual_count = actual_counts.get(branch_id, 0)
            completed_count = completed_counts.get(branch_id, 0)
            
            cursor.execute(
                'UPDATE project_git_branchs SET task_count = ?, completed_task_count = ? WHERE id = ?',
                (actual_count, completed_count, branch_id)
            )
            
            if actual_count > 0:
                print(f"   ‚úÖ {branch_name}: {actual_count} tasks ({completed_count} completed)")
                fixes += 1
        
        if fixes > 0:
            conn.commit()
            print(f"‚úÖ Fixed task counts for {fixes} branches")
        else:
            print("‚úÖ All task counts are correct")
        
        # Check for JSON corruption in subtasks
        print("üîß Checking subtask assignees JSON format...")
        cursor.execute('SELECT id, assignees FROM task_subtasks WHERE assignees IS NOT NULL')
        rows = cursor.fetchall()
        
        corrupted_count = 0
        for subtask_id, assignees in rows:
            if assignees.startswith('"') and assignees.endswith('"'):
                try:
                    # Fix double-encoded JSON
                    fixed_assignees = json.loads(assignees)
                    cursor.execute('UPDATE task_subtasks SET assignees = ? WHERE id = ?', (fixed_assignees, subtask_id))
                    corrupted_count += 1
                except:
                    print(f"   ‚ö†Ô∏è  Could not fix subtask {subtask_id}")
        
        if corrupted_count > 0:
            conn.commit()
            print(f"‚úÖ Fixed {corrupted_count} corrupted JSON records")
        else:
            print("‚úÖ All subtask assignees are properly formatted")
        
        conn.close()
        return True
        
    except Exception as e:
        print(f"‚ùå Error verifying database: {e}")
        return False

def restore_database_advanced(backup_path: str, debug: bool = False) -> bool:
    """Advanced database restoration with verification and repair"""
    print(f"üîß Advanced Database Restoration")
    print("=" * 50)
    
    if not os.path.exists(backup_path):
        print(f"‚ùå Backup file not found: {backup_path}")
        return False
    
    # Step 1: Backup current database (only in debug mode)
    timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
    
    if debug:
        current_backup = f"dhafnck_mcp.db.pre-restore-{timestamp}"
        try:
            print(f"üîÑ Creating backup of current database...")
            run_subprocess([
                "docker", "cp", f"dhafnck-mcp-server:/data/dhafnck_mcp.db", current_backup
            ], check=True)
            print(f"‚úÖ Current database backed up to: {current_backup}")
        except subprocess.CalledProcessError as e:
            print(f"‚ùå Failed to backup current database: {e}")
            return False
    else:
        print(f"üîÑ Skipping pre-restore backup (not in debug mode)")
        current_backup = None
    
    # Step 2: Verify backup file
    print(f"üîç Verifying backup file: {backup_path}")
    if not verify_database_integrity(backup_path):
        print("‚ùå Backup file verification failed")
        return False
        
    try:
        # Step 3: Restore to container (with optional working copy for debug)
        if debug:
            # Create working copy and fix it (debug mode only)
            working_copy = f"dhafnck_mcp.db.restored-{timestamp}"
            shutil.copy2(backup_path, working_copy)
            print(f"‚úÖ Created working copy: {working_copy}")
            
            # Fix working copy
            if not verify_database_integrity(working_copy):
                print("‚ùå Failed to fix working copy")
                return False
            
            # Restore from working copy
            print(f"üîÑ Restoring database to container...")
            run_subprocess([
                "docker", "cp", working_copy, f"dhafnck-mcp-server:/data/dhafnck_mcp.db"
            ], check=True)
        else:
            # Direct restore without working copy (normal mode)
            print(f"üîÑ Restoring database to container...")
            run_subprocess([
                "docker", "cp", backup_path, f"dhafnck-mcp-server:/data/dhafnck_mcp.db"
            ], check=True)
        
        # Fix permissions
        fix_database_permissions()
        
        # Step 5: Verify restored database
        print(f"üîç Verifying restored database...")
        result = run_subprocess([
            "docker", "exec", "dhafnck-mcp-server", "python", "-c", '''
import sqlite3
conn = sqlite3.connect("/data/dhafnck_mcp.db")
cursor = conn.cursor()

cursor.execute("PRAGMA integrity_check;")
integrity = cursor.fetchone()[0]
print("Integrity: " + integrity)

cursor.execute("SELECT name, task_count FROM project_git_branchs WHERE task_count > 0")
branches = cursor.fetchall()
print("Branches with tasks: " + str(len(branches)))
for name, count in branches:
    print("  " + name + ": " + str(count) + " tasks")

cursor.execute("SELECT COUNT(*) FROM task_subtasks WHERE assignees LIKE '\\"%\\"'")
corrupted = cursor.fetchone()[0]
print("Corrupted subtasks: " + str(corrupted))

conn.close()
'''
        ], capture_output=True, text=True)
        
        if result.returncode == 0:
            print(f"‚úÖ Database verification completed")
            print(f"   Output: {result.stdout}")
            success = "Integrity: ok" in result.stdout and "Corrupted subtasks: 0" in result.stdout
        else:
            print(f"‚ùå Database verification failed: {result.stderr}")
            success = False
        
        # Step 6: Restart frontend
        if success:
            print(f"üîÑ Restarting frontend to refresh UI...")
            run_subprocess([
                "docker-compose", "-f", "dhafnck_mcp_main/docker/docker-compose.yml",
                "restart", "dhafnck-frontend"
            ], capture_output=True, text=True)
            
            print(f"üéâ Database restoration completed successfully!")
            print(f"‚úÖ Original database backed up to: {current_backup}")
            print(f"‚úÖ Restored database verified and ready for use")
            print(f"üåê Frontend available at: http://localhost:3800")
        
        # Clean up working copy (debug mode only)
        if debug and 'working_copy' in locals():
            os.remove(working_copy)
        
        return success
        
    except Exception as e:
        print(f"‚ùå Restoration failed: {e}")
        return False

def verify_container_database(debug: bool = False) -> bool:
    """Verify database in container"""
    print(f"üîç Verifying container database...")
    
    try:
        # Check if container is running
        result = run_subprocess([
            "docker", "ps", "--filter", "name=dhafnck-mcp-server", "--format", "{{.Names}}"
        ], capture_output=True, text=True, check=True)
        
        if "dhafnck-mcp-server" not in result.stdout:
            print("‚ùå Container 'dhafnck-mcp-server' is not running")
            return False
        
        # Verify database directly in container without temp files
        print("üîß Running database verification inside container...")
        result = run_subprocess([
            "docker", "exec", "dhafnck-mcp-server", "python", "-c", '''
import sqlite3
import json

try:
    conn = sqlite3.connect("/data/dhafnck_mcp.db", timeout=10.0)
    cursor = conn.cursor()
    
    # Check integrity
    cursor.execute("PRAGMA integrity_check;")
    integrity = cursor.fetchone()[0]
    print("Database integrity: " + integrity)
    
    if integrity != "ok":
        print("ERROR: Database integrity check failed")
        exit(1)
    
    # Check task counts
    cursor.execute("SELECT git_branch_id, COUNT(*) FROM tasks GROUP BY git_branch_id")
    actual_counts = dict(cursor.fetchall())
    
    cursor.execute("SELECT git_branch_id, COUNT(*) FROM tasks WHERE status = 'done' GROUP BY git_branch_id")
    completed_counts = dict(cursor.fetchall())
    
    cursor.execute("SELECT id, name, task_count, completed_task_count FROM project_git_branchs")
    branches = cursor.fetchall()
    
    inconsistent_branches = 0
    for branch_id, branch_name, stored_count, stored_completed in branches:
        actual_count = actual_counts.get(branch_id, 0)
        completed_count = completed_counts.get(branch_id, 0)
        
        if stored_count != actual_count or stored_completed != completed_count:
            inconsistent_branches += 1
            print(f"MISMATCH: {branch_name} - stored: {stored_count}/{stored_completed}, actual: {actual_count}/{completed_count}")
    
    if inconsistent_branches > 0:
        print(f"ERROR: Found {inconsistent_branches} branches with inconsistent task counts")
    else:
        print("‚úÖ All task counts are consistent")
    
    # Check subtask JSON corruption
    cursor.execute("SELECT COUNT(*) FROM task_subtasks WHERE assignees LIKE '\\"%\\"'")
    corrupted = cursor.fetchone()[0]
    
    if corrupted > 0:
        print(f"ERROR: Found {corrupted} corrupted subtask assignees")
    else:
        print("‚úÖ All subtask assignees are properly formatted")
    
    # Final status
    if integrity == "ok" and inconsistent_branches == 0 and corrupted == 0:
        print("SUCCESS: Database verification passed")
        exit(0)
    else:
        print("ERROR: Database verification failed")
        exit(1)
        
except Exception as e:
    print(f"ERROR: Database verification failed: {e}")
    exit(1)
finally:
    if 'conn' in locals():
        conn.close()
'''
        ], capture_output=True, text=True)
        
        if result.returncode == 0:
            print("‚úÖ Database verification completed successfully")
            if debug:
                print(f"Debug output: {result.stdout}")
            return True
        else:
            print("‚ùå Database verification failed")
            print(f"Error details: {result.stdout}")
            return False
        
    except Exception as e:
        print(f"‚ùå Error verifying container database: {e}")
        return False

def main():
    # Check for debug flag
    debug = "--debug" in sys.argv
    if debug:
        print("üêõ Debug mode enabled - temporary files will be created for troubleshooting")
    choices = [
        "Start (normal - production mode) - Stable, production-ready setup with SQLite",
        "Start (postgresql - PostgreSQL mode) - Production-ready setup with PostgreSQL",
        "Start (development - with debug & hot reload) - Debug mode with live code updates",
        "Start (local - no auth, local development) - Simplified, no-auth for local testing",
        "Start (redis - with Redis session persistence) - Adds Redis for session storage",
        "Run E2E tests - Execute end-to-end tests in dev mode",
        "Stop containers - Shutdown all running containers",
        "Show logs - View real-time output from containers",
        "Shell into container - Access bash shell inside container",
        "Restart containers - Stop and restart selected mode",
        "Build backend only - Rebuild just the backend container",
        "Build frontend only - Rebuild just the frontend container",
        "Build both - Rebuild both backend and frontend containers",
        "Clean backend only - Remove backend container and image",
        "Clean frontend only - Remove frontend container and image",
        "Clean both - Remove both backend and frontend containers/images",
        "Clean & Rebuild (full reset) - Backup database + clean rebuild containers",
        "Import/Restore SQLite DB - Copy database into container",
        "Restore Database (Advanced) - Restore with verification and repair",
        "Verify Database - Check database integrity and fix issues",
        "Verify PostgreSQL Database - Check PostgreSQL connection and schema",
        "Fix Database Permissions - Fix readonly database errors",
        "Inspect MCP Server - Open MCP inspector at http://localhost:8000/mcp/",
        "Exit - Close this menu"
    ]
    
    while True:
        choice = questionary.select(
            "Select a Docker action:",
            choices=choices
        ).ask()
        
        # Extract the main action text before the description for comparison
        choice_main = choice.split(" - ")[0]
        
        if choice_main == "Start (normal - production mode)":
            # Normal mode: Production-like environment
            # - Runs with default settings from base compose file
            # - No debug or hot reload; optimized for stability
            # - Should be started first to establish baseline functionality
            print("\nStarting in Normal Mode (Production-like environment with SQLite):")
            print("- This mode uses the base configuration for a stable, production-ready setup.")
            print("- Uses SQLite database for simplicity and portability.")
            print("- No debugging or hot reload features are enabled.")
            print("- Frontend will be available at http://localhost:3800")
            print("- Recommended to run this mode first to verify core functionality before other modes.\n")
            compose_files = get_compose_files("normal")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up"])
            fix_database_permissions()
        elif choice_main == "Start (postgresql - PostgreSQL mode)":
            # PostgreSQL mode: Production environment with PostgreSQL
            # - Uses PostgreSQL instead of SQLite for production-ready database
            # - Supports JSONB operations and better performance
            # - Includes Redis for session management
            print("\nStarting in PostgreSQL Mode (Production environment with PostgreSQL):")
            print("- This mode uses PostgreSQL database for production-ready setup.")
            print("- Supports JSONB operations and better performance than SQLite.")
            print("- Includes Redis for session management.")
            print("- Database will be initialized with schema on first run.")
            print("- Frontend will be available at http://localhost:3800")
            print("- PostgreSQL will be available at localhost:5432\n")
            compose_files = get_compose_files("postgresql")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up"])
        elif choice_main == "Start (development - with debug & hot reload)":
            # Development mode: Enables debugging and hot reload
            # - Depends on base configuration being functional
            # - Run after testing normal mode to ensure base setup works
            # - Useful for developers needing live feedback on code changes
            print("\nStarting in Development Mode (with Debug & Hot Reload):")
            print("- This mode builds on the base configuration, adding debugging capabilities.")
            print("- Hot reload is enabled via volume mounts for immediate code change feedback.")
            print("- Frontend will be available at http://localhost:3800")
            print("- Ensure Normal Mode works first, as this mode depends on a stable base setup.\n")
            compose_files = get_compose_files("dev-fast")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up"])
            fix_database_permissions()
        elif choice_main == "Start (local - no auth, local development)":
            # Local mode: Simplified setup for local development
            # - Disables authentication for ease of access
            # - Depends on base configuration; run after normal mode is verified
            # - Ideal for quick local testing without security barriers
            print("\nStarting in Local Mode (No Auth, Local Development):")
            print("- This mode uses the base configuration but disables authentication for simplicity.")
            print("- Designed for local testing without security overhead.")
            print("- Frontend will be available at http://localhost:3800")
            print("- Run after verifying Normal Mode to ensure the base setup is functional.\n")
            compose_files = get_compose_files("local")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up"])
            fix_database_permissions()
        elif choice_main == "Start (redis - with Redis session persistence)":
            # Redis mode: Adds session persistence with Redis
            # - Depends on base configuration and Redis service availability
            # - Run after normal mode to ensure core app works before adding persistence
            # - Useful for testing session handling in a stateful environment
            print("\nStarting in Redis Mode (with Redis Session Persistence):")
            print("- This mode extends the base configuration to include Redis for session storage.")
            print("- Requires Redis service to be available alongside the main application.")
            print("- Frontend will be available at http://localhost:3800")
            print("- Run after Normal Mode to confirm core app functionality before adding persistence.\n")
            compose_files = get_compose_files("redis")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up"])
            fix_database_permissions()
        elif choice_main == "Run E2E tests":
            # Use development mode for testing
            print("\nRunning End-to-End (E2E) Tests:")
            print("- This action starts containers in Development Mode (detached) for testing.")
            print("- Copies the latest E2E test files into the running container.")
            print("- Executes tests using pytest inside the container.")
            print("- Ensure Development Mode setup is functional before running tests.\n")
            compose_files = get_compose_files("dev-fast")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up", "-d"])
            # Copy the latest e2e tests into the running container
            run_subprocess([DOCKER, "cp", "dhafnck_mcp_main/tests/e2e", "dhafnck-mcp-server:/app/tests/"])
            run_subprocess([
                DOCKER, "exec", "-it", "dhafnck-mcp-server",
                "pytest", "/app/tests/e2e"
            ])
        elif choice_main == "Stop containers":
            # Stop all possible configurations
            print("\nStopping All Containers:")
            print("- This action will stop containers across all modes (Normal, PostgreSQL, Development, Local, Redis).")
            print("- Ensures a clean shutdown of all running services.")
            print("- Run this before switching modes or to free up system resources.\n")
            for mode in ["normal", "postgresql", "development", "dev-fast", "local", "redis"]:
                compose_files = get_compose_files(mode)
                run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["down"], 
                             capture_output=True, text=True)  # Suppress output for cleanup
        elif choice_main == "Show logs":
            # Ask which mode to show logs for
            print("\nShowing Container Logs:")
            print("- Logs provide real-time output from running containers.")
            print("- You will be prompted to select the mode for which to view logs.")
            print("- Ensure the relevant mode is running before attempting to view logs.\n")
            mode_choice = questionary.select(
                "Which mode's logs do you want to see?",
                choices=[
                    "Normal",
                    "PostgreSQL",
                    "Development",
                    "Local",
                    "Redis"
                ]
            ).ask()
            mode_map = {
                "Normal": "normal",
                "PostgreSQL": "postgresql",
                "Development": "dev-fast",
                "Local": "local",
                "Redis": "redis"
            }
            mode_key = mode_map[mode_choice]
            compose_files = get_compose_files(mode_key)
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["logs", "-f"])
        elif choice_main == "Shell into container":
            container_choice = questionary.select(
                "Which container do you want to shell into?",
                choices=[
                    "Backend (dhafnck-mcp-server)",
                    "Frontend (dhafnck-frontend)",
                    "PostgreSQL (dhafnck-postgres)",
                    "Redis (dhafnck-redis)"
                ]
            ).ask()
            container_map = {
                "Backend (dhafnck-mcp-server)": "dhafnck-mcp-server",
                "Frontend (dhafnck-frontend)": "dhafnck-frontend",
                "PostgreSQL (dhafnck-postgres)": "dhafnck-postgres",
                "Redis (dhafnck-redis)": "dhafnck-redis"
            }
            container_name = container_map[container_choice]
            print(f"\nOpening Shell into {container_choice}:")
            print(f"- This action opens a shell inside the {container_name} container.")
            print("- Useful for debugging or manual configuration within the container.")
            print("- Ensure the container is running before attempting to access the shell.\n")
            # Choose appropriate shell based on container
            if container_name == "dhafnck-frontend":
                shell_cmd = "/bin/sh"
            elif container_name == "dhafnck-postgres":
                # For PostgreSQL, offer direct psql access
                print("Opening PostgreSQL shell (psql)...")
                run_subprocess([
                    "docker", "exec", "-it", container_name, 
                    "psql", "-U", "dhafnck_user", "-d", "dhafnck_mcp"
                ])
                continue
            else:
                shell_cmd = "/bin/bash"
            
            run_subprocess([
                "docker", "exec", "-it", container_name, shell_cmd
            ])
        elif choice_main == "Restart containers":
            # Ask which mode to restart
            print("\nRestarting Containers:")
            print("- This action stops and then restarts containers for the selected mode.")
            print("- You will be prompted to choose the mode to restart.")
            print("- Useful for applying configuration changes or recovering from errors.\n")
            mode_choice = questionary.select(
                "Which mode do you want to restart?",
                choices=[
                    "Normal",
                    "PostgreSQL",
                    "Development",
                    "Local",
                    "Redis"
                ]
            ).ask()
            mode_map = {
                "Normal": "normal",
                "PostgreSQL": "postgresql",
                "Development": "dev-fast",
                "Local": "local",
                "Redis": "redis"
            }
            mode_key = mode_map[mode_choice]
            compose_files = get_compose_files(mode_key)
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["down"])
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up", "-d"])
        elif choice_main == "Rebuild frontend only":
            print("\nRebuilding Frontend Container:")
            print("- This will stop, remove, and rebuild only the frontend container.")
            print("- The frontend will be available at http://localhost:3800 after rebuild.")
            print("- Other services will remain running.\n")
            
            # Stop and remove frontend container and image
            run_subprocess([DOCKER, "stop", "dhafnck-frontend"], capture_output=True, text=True)
            run_subprocess([DOCKER, "rm", "dhafnck-frontend"], capture_output=True, text=True)
            run_subprocess([DOCKER, "rmi", "dhafnck/frontend:latest"], capture_output=True, text=True)
            
            # Get current mode to rebuild with correct compose files
            mode_choice = questionary.select(
                "Which mode are you currently running?",
                choices=[
                    "Normal",
                    "Development",
                    "Local",
                    "Redis"
                ]
            ).ask()
            mode_map = {
                "Normal": "normal",
                "Development": "dev-fast",
                "Local": "local",
                "Redis": "redis"
            }
            mode_key = mode_map[mode_choice]
            compose_files = get_compose_files(mode_key)
            
            # Rebuild and start frontend
            print("Building frontend container...")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["build", "--no-cache", "dhafnck-frontend"])
            print("Starting frontend container...")
            run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up", "-d", "dhafnck-frontend"])
            print("\nFrontend rebuild complete! Available at http://localhost:3800")
        elif choice_main == "Clean & Rebuild (full reset)":
            # Ask which mode to clean and rebuild
            print("\nCleaning & Rebuilding (Full Reset):")
            print("- This action automatically backs up your database before cleaning.")
            print("- Removes containers, images, and volumes, then rebuilds from scratch.")
            print("- After rebuild, use 'Restore Database (Advanced)' to restore your data.")
            print("- You will be prompted to select the mode to reset or all modes for a complete cleanup.")
            print("- Run this to resolve persistent issues or start with a fresh environment.\n")
            mode_choice = questionary.select(
                "Which mode do you want to clean and rebuild?",
                choices=[
                    "Normal",
                    "Development", 
                    "Local",
                    "Redis",
                    "All modes (complete cleanup)"
                ]
            ).ask()
            
            # Map display names to mode keys
            mode_map = {
                "Normal": "normal",
                "Development": "dev-fast",
                "Local": "local", 
                "Redis": "redis",
                "All modes (complete cleanup)": "all"
            }
            mode_key = mode_map[mode_choice]
            
            # Backup current DBs before cleaning
            timestamp = datetime.datetime.now().strftime("%Y%m%d-%H%M%S")
            dbs = [
                ("/data/dhafnck_mcp.db", f"dhafnck_mcp.db.bak-{timestamp}"),
                ("/data/dhafnck_mcp_test.db", f"dhafnck_mcp_test.db.bak-{timestamp}")
            ]
            for db_path, backup_name in dbs:
                print(f"Backing up {db_path} to {backup_name} (if exists)...")
                # Try to copy from container to host, ignore errors if file doesn't exist
                try:
                    run_subprocess([
                        "docker", "cp", f"dhafnck-mcp-server:{db_path}", backup_name
                    ], check=True)
                except subprocess.CalledProcessError:
                    print(f"  (No {db_path} found in container, skipping)")
            print("Backup complete. Proceeding with reset...\n")
            
            if mode_key == "all":
                print("\n‚ö†Ô∏è  This will stop and remove all containers, images, volumes, and cache, then rebuild everything from scratch.\n")
                print("This includes the frontend container running on port 3800.\n")
                # Stop all configurations
                for mode in ["normal", "development", "dev-fast", "local", "redis"]:
                    compose_files = get_compose_files(mode)
                    run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["down", "-v", "--rmi", "all", "--remove-orphans"], 
                                 capture_output=True, text=True)
                
                # Clean Docker system and remove frontend image
                run_subprocess([DOCKER, "rmi", "dhafnck/frontend:latest"], capture_output=True, text=True)
                run_subprocess([DOCKER, "builder", "prune", "-f"])
                
                # Ask which mode to rebuild after cleaning all
                rebuild_choice = questionary.select(
                    "Which mode do you want to rebuild and start?",
                    choices=[
                        "Normal",
                        "Development",
                        "Local", 
                        "Redis"
                    ]
                ).ask()
                rebuild_map = {
                    "Normal": "normal",
                    "Development": "dev-fast",
                    "Local": "local",
                    "Redis": "redis"
                }
                rebuild_key = rebuild_map[rebuild_choice]
                compose_files = get_compose_files(rebuild_key)
                run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["build", "--no-cache"])
                run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up", "-d"])
                
                # Show completion message with backup info
                print(f"\n‚úÖ Clean & Rebuild completed successfully!")
                print(f"üîÑ Your database has been backed up to: dhafnck_mcp.db.bak-{timestamp}")
                print(f"üöÄ {rebuild_choice} mode is now running with a clean database")
                print(f"üìã Next step: Use 'Restore Database (Advanced)' to restore your data")
                print(f"üåê Frontend available at: http://localhost:3800")
            else:
                print(f"\n‚ö†Ô∏è  This will stop and remove containers, images, and volumes for {mode_choice} mode, then rebuild.\n")
                # Clean only the selected mode
                compose_files = get_compose_files(mode_key)
                run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["down", "-v", "--rmi", "all", "--remove-orphans"])
                run_subprocess([DOCKER, "builder", "prune", "-f"])
                run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["build", "--no-cache"])
                run_subprocess(flatten_compose_command(DOCKER_COMPOSE) + compose_files + ["up", "-d"])
                
                # Show completion message with backup info
                print(f"\n‚úÖ Clean & Rebuild completed successfully!")
                print(f"üîÑ Your database has been backed up to: dhafnck_mcp.db.bak-{timestamp}")
                print(f"üöÄ {mode_choice} mode is now running with a clean database")
                print(f"üìã Next step: Use 'Restore Database (Advanced)' to restore your data")
                print(f"üåê Frontend available at: http://localhost:3800")
        elif choice_main == "Import/Restore SQLite DB":
            print("\nImporting/Restoring SQLite Database:")
            print("- This action copies a SQLite database file into the container.")
            print("- Automatically fixes database permissions after import.")
            print("- The frontend will automatically display restored data via API calls.")
            print("- You will be prompted to select which database (Main or Test) to restore.")
            print("- Ensure the container is running to successfully import the database.\n")
            db_choice = questionary.select(
                "Which DB do you want to import/restore?",
                choices=[
                    "Main DB (production)",
                    "Test DB"
                ]
            ).ask()
            db_map = {
                "Main DB (production)": "/data/dhafnck_mcp.db",
                "Test DB": "/data/dhafnck_mcp_test.db"
            }
            db_path = db_map[db_choice]
            host_file = questionary.path(
                "Enter the path to the SQLite .db file to import (on your host):"
            ).ask()
            if not host_file or not os.path.isfile(host_file):
                print(f"File not found: {host_file}")
            else:
                print(f"Copying {host_file} to container:{db_path} ...")
                try:
                    run_subprocess([
                        "docker", "cp", host_file, f"dhafnck-mcp-server:{db_path}"
                    ], check=True)
                    print(f"Successfully imported {host_file} to {db_path} in container.")
                    print("üîß Fixing permissions for imported database...")
                    fix_database_permissions()
                    
                    print("‚úÖ Database restore completed successfully!")
                    print("üí° The frontend will automatically display the restored data via API calls")
                    
                except subprocess.CalledProcessError as e:
                    print(f"Failed to import DB: {e}")
        elif choice_main == "Restore Database (Advanced)":
            print("\nAdvanced Database Restoration:")
            print("- This action performs comprehensive database restoration with verification and repair.")
            print("- Automatically backs up current database before restoration.")
            print("- Verifies backup file integrity and repairs JSON corruption.")
            print("- Fixes task counts and validates database relationships.")
            print("- Restarts frontend to display restored data.")
            print("- Ensure the container is running before proceeding.\n")
            
            backup_file = questionary.path(
                "Enter the path to the backup .db file to restore:"
            ).ask()
            
            if not backup_file or not os.path.isfile(backup_file):
                print(f"‚ùå File not found: {backup_file}")
            else:
                success = restore_database_advanced(backup_file, debug)
                if success:
                    print("\nüéâ Advanced database restoration completed successfully!")
                else:
                    print("\n‚ùå Advanced database restoration failed. Check the output above for details.")
        elif choice_main == "Verify Database":
            print("\nDatabase Verification and Repair:")
            print("- This action checks database integrity and fixes common issues.")
            print("- Verifies task counts in branches and repairs if needed.")
            print("- Checks and fixes JSON corruption in subtask assignees.")
            print("- Validates database relationships and structure.")
            print("- The database will be automatically repaired if issues are found.\n")
            
            success = verify_container_database(debug)
            if success:
                print("\n‚úÖ Database verification completed successfully!")
            else:
                print("\n‚ùå Database verification found issues. Check the output above for details.")
        elif choice_main == "Verify PostgreSQL Database":
            print("\nPostgreSQL Database Verification:")
            print("- This action checks PostgreSQL connection and schema.")
            print("- Verifies that required tables exist and are accessible.")
            print("- Tests database connectivity from within the container.")
            print("- Useful for troubleshooting PostgreSQL setup issues.\n")
            
            success = verify_postgresql_database()
            if success:
                print("\n‚úÖ PostgreSQL database verification completed successfully!")
            else:
                print("\n‚ùå PostgreSQL database verification failed. Check the output above for details.")
        elif choice_main == "Fix Database Permissions":
            print("\nFixing Database Permissions:")
            print("- This action fixes database file ownership issues that cause 'readonly database' errors.")
            print("- It changes the database file owner from host user to container user.")
            print("- This is especially useful after database backup/restore operations.\n")
            fix_database_permissions()
        elif choice_main == "Inspect MCP Server":
            print("\nStarting MCP Inspector:")
            print("- This will open the MCP inspector for your server at http://localhost:8000/mcp/")
            print("- Press Ctrl+C to stop the inspector and clean up resources.")
            print("- The inspector allows you to explore and test MCP server capabilities.\n")
            
            inspector_process = None
            try:
                # Define cleanup function
                def cleanup_inspector(signum=None, frame=None):
                    print("\n\nüõë Stopping MCP Inspector...")
                    if inspector_process:
                        inspector_process.terminate()
                        try:
                            inspector_process.wait(timeout=5)
                        except subprocess.TimeoutExpired:
                            inspector_process.kill()
                    print("‚úÖ Inspector stopped and resources cleaned up.")
                    # Reset signal handler to default
                    signal.signal(signal.SIGINT, signal.default_int_handler)
                
                # Set up signal handler for Ctrl+C
                signal.signal(signal.SIGINT, cleanup_inspector)
                
                # Run the inspector
                inspector_process = subprocess.Popen([
                    "npx", "@modelcontextprotocol/inspector", "http://localhost:8000/mcp/"
                ])
                
                print("üîç MCP Inspector is running...")
                print("üåê Opening browser at http://localhost:5173 (default inspector port)")
                print("üì° Connecting to MCP server at http://localhost:8000/mcp/")
                print("\nPress Ctrl+C to stop the inspector...\n")
                
                # Wait for the process to complete
                inspector_process.wait()
                
            except KeyboardInterrupt:
                # This will be caught by our signal handler
                pass
            except Exception as e:
                print(f"‚ùå Error running MCP inspector: {e}")
                if inspector_process:
                    cleanup_inspector()
            finally:
                # Ensure cleanup even if something unexpected happens
                if inspector_process and inspector_process.poll() is None:
                    cleanup_inspector()
        elif choice_main == "Exit":
            print("Goodbye!")
            break

if __name__ == "__main__":
    main()